\section{Conclusion}
\label{Sec-Conclusion}

In this paper, we describe a technique to implement a scalable, linearizable priority queue based on a skiplist, divided into a sequential and a parallel part. Our scheme simultaneously enables parallel \texttt{PQ::add()} operations as well as sequential batched \texttt{PQ::removeMin()} operations. The sequential part is beneficial for batched removals, which are performed by a special \emph{server thread}. While detaching the sequential part from the parallel part is non-negligible cost-wise, the sequential part has the potential to serve multiple subsequent removals at a small constant cost. 
The parallel part is beneficial for concurrent insertions of elements with bigger keys (smaller priority), not likely to be removed soon. 
In other words, we integrate the flat combining/delegation paradigm introduced in prior work with disjoint-access parallelism.

In addition, we present a novel priority queue elimination algorithm, where \texttt{PQ::add()} operations with keys smaller than the priority queue minimum can eliminate with \texttt{PQ::removeMin()} operations. We permit \texttt{PQ::add()} operations, with keys small enough, to linger in the elimination array, waiting to become eligible for elimination. If the elimination is not possible, the operation is delegated to the server thread. Batched removals (combining) by the server thread is well-integrated with both: (1) parallelism of \texttt{add()} operations with bigger keys; and (2) the elimination algorithm, that possibly delegates failed elimination attempts (of elements with smaller keys) to the server thread in a natural manner. Our priority queue integrates delegation, combining, and elimination, while still leveraging the parallelism potential of insertions.
