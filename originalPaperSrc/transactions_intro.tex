\section{Hardware Transactions}
\label{Sec-HardwareTransactions}

%Designing concurrent data structures involves complicated synchronization between threads, often implemented using CAS instructions. Certain design decisions circumvent the limitation that we cannot change or check multiple locations atomically. For example, our priority queue design packs a value and a stamp together in order to check both in the same CAS operation, as explained in section~\ref{Sec-Design-Elimination}. Also, we have to use an extra value in the elimination array, INPROG, to mark an element that is being added or removed by the server thread. Finally, the design of the underlying skiplist is complicated by the need to synchronize parallel adds with the \texttt{moveHead()} operation. 

Transactional memory~\cite{Herlihy:1993:TMA:173682.165164} is an optimistic mechanism to synchronize threads accessing shared data. Threads are allowed to execute critical sections speculatively in parallel, but, if there is a data conflict, one of them has to roll back and retry its critical section. Recently, IBM and Intel added HTM instructions to their processors~\cite{wang:2012:pact,haswell:2012:rtm}. 
In our priority queue implementation, we used Intel's Transactional Synchronization Extensions (TSX)~\cite{haswell:2012:rtm} to simplify the implementation and reduce the overhead caused by the synchronization necessary to manage a sequential and a parallel skiplist. 
%In this section, we discuss the necessary changes, adequacy, and results of using TSX to simplify and improve performance of our priority queue. 
We evaluate our results on an Intel Haswell four core processor, Core i7-4770, with hardware transactions enabled (restricted transactional memory - RTM), running at 3.4GHz. There are 8GB of RAM shared across the machine and each core has a 32KB L1 cache. Hyperthreading was enabled on our machine so we collected results using all 8 hardware threads. Hyperthreading causes resource sharing between the hyperthreads, including L1 cache sharing, when running with more than 4 threads, thus it can negatively impact results, especially for hardware transactions. We did not notice a hyperthreading effect in our experiments. We used the GCC 4.8 compiler with support for RTM and optimizations enabled (-O3).  
